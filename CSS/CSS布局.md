### 单位

#### 1. 长度 

①、**px**

- `px`就是指像素点的数量，100px就是100个像素点的长度。
- `px`的缺点是它的绝对尺寸，调整起来很麻烦，**假如有五个属性用到了px，那就要同时改这五个地方**。

```css
width:50px;
height:50px;
```



②、**em**

- 和绝对尺寸相对的一个概念是相对尺寸，也就是它先确定一个基准，然后其他尺寸都以这个基准来计算大小，当要修改时，**只要改一下基准值，其他尺寸就都按比例自动改变了**。
- `em`是指相对于`font-size`的大小，如果一个容器内所有的子元素都使用em单位，那么，**当要调整容器的大小时，只要调整font-size的值即可**。现在选择器里定义一个`font-size:10px`，然后其他尺寸单位都改为em。

> 1em=10px
>
> 1.5em=15px

#### 2. 颜色

①、**颜色名称**

②**HSL**

- HSL是用**色相（hue）、饱和度（saturation）和亮度（lightness）**调配出的颜色。
- 色相也就是我们日常说的“颜色”
- 饱和度是指纯色与灰色混合之后，纯色的占比
- 亮度的取值范围也是从0%到100%，表示从暗到明的程度，0%表示全黑，100%表示全白，50%表示纯色。

③**RGB**

- RGB颜色模式是用红色、绿色、蓝色3色调配出的颜色，**RGB色值是以 “#” 号开头的6个十六进制数**，每种颜色用2位十六进制表示，**取值范围是从#00到#ff**

④**HSLA/RGBA**

- HSLA/RGBA比HSL/RGB多出的最后一个A，学名叫“alpha”通道，实践中我们把它当作一个**不透明度值**对待

⑤**transparent**

- transparent关键字表示透明色，可以用`color:transparent`实现效果，也可以通过RGBA/HSLA模式下把A值设置为0，或者使用`visibility：hidden`属性。

### 盒模型

#### 1. 内边距、边框和外边距

- 一个元素就是一个矩形“盒子”，它的内容（content）就像是相框中的照片，**内容与边框（border）之前的留白称为内边距（padding），元素与元素之间的间距称为外边距（margin）**。我们经常使用的width和height，是指内容的宽和高，不包括内边距、边框和外边距。

#### 2. box-sizing

在网页布局中更多考虑**内容+内边距+边框（content+padding+border）三者整体的尺寸**

- box-sizing的属性中有两个可选的值。一个是**content-box**，表示盒子的**width和height以content的边界计算**；另一个是**border-box**，表示盒子的**width和height以border的边界计算**。

- 推荐使用border-box模型，设置好width、height属性止呕，再调整padding和border时，都只对盒内有影响，不会影响到盒子外面的元素

  ```css
  .box:nth-child(1) {box-sizing: border-box;}
  ```

  

### 定位

每个元素在页面上都有一个默认的位置，如果要让元素偏离这个默认位置，有两种方法：**一种时相对定位；一种时绝对定位**

#### 1. 相对定位

- 相对定位是指以元素默认位置为起点，移动元素到一个新的位置，此时的`top、left、right、bottom`都是相对于元素默认位置计算的。

```css
/*相对定位*/
.eight:nth-child(2) div :nth-child(1){
    position:relative;
    top:3em;
}
```

#### 2. 绝对定位

- **绝对定位不是以默认位置计算的，是以它的父元素的位置作为起点计算的**，而它的父元素，必须是被定位过的（被相对定位过或者被绝对定位过），如果父元素没被定位过，那就看父元素的父元素（也就是祖父元素）是否被定位过，直至找到一个被定位过的祖先，**要是全找遍了都没有，那就以整个窗口body为父元素**。
- 先选一个被定位过的容器，再对容器里的子元素进行绝对定位。
- 属性`top、left、right、bottom`都只有在元素被定位过后才起作用
- **容器采用相对定位，子元素采用绝对定位**

### 布局

#### 1. flex布局

- 要使用flex布局，需要先在父元素上生命`display：flex;`这样它的所有直系子元素就成为flex元素。
- flex布局本质上是令所有子元素排列在一条轴线上，尽管在子元素较多时可以回行显示，但逻辑上仍是同一行。

①、**居中**

居中有垂直居中，水平居中，垂直水平居中三种。

```css
/*表示垂直居中*/
div:nth-child(1){
    align-items: center;
}
/*表示水平居中*/
div:nth-child(2){
    justify-content: center;
}
/*表示垂直水平居中*/
div:nth-child(3){
    align-items: center;
	justify-content: center;
}
```

②、**横向排列元素**

```css
/*表示居左*/
justify-content:flex-start;
/*表示居右*/
justify-content:flex-end;
/*表示首尾得两个元素挨着容器边缘，中间得其他元素平均排列*/
justify-content:space-between
/*表示首尾的两个元素与容器边框的距离是元素之间间距的一半，各元素平均排列。*/
justify-content: space-around
```

③、**纵向排列元素**

当子元素纵向排列时，在容器中增加`flex-direction:column;`属性就好。

④、**轴**

flex布局**不使用**`left、right、top、bottom`这些方向词，而是引入轴。

- 轴——像数轴那样的有方向的线，用两条数轴可以定义一个平面直角坐标系。所以flex布局就有了“主轴”和“交叉轴”的概念，“主轴”是子元素延伸的方向，“交叉轴”是与“主轴”垂直的轴。
- **flex-start**代表轴的起点位置，**flex-end**代表轴的终点位置。
- **flex-direction**的用途是设置主轴的方向，默认值是**row**，表示从左到右延伸，另一个常用值就是**column**，表示从上到下延伸，定义了主轴的方向，同时也就定义了交叉轴的方向。

![](G:\图片\轴的方向.png)

#### 2. grid布局

- grid布局的思路是对早年间table布局的升华，即把网页看成有若干行和列的网格，然后让各元素分别与网络线对齐。

- 要使用grid布局，要先在父元素上声明`display：grid；`，这样它的所有直系子元素就会成为grid元素。

- `grid-template-columns`用于规定**每一行要分成几列，以及每列的尺寸，`repeat(4, 1fr)`表示把一行平均分成4份，1fr是一个长度单位，表示平分之后的1份的宽度。**

  ```css
  .container:nth-child(1){
      grid-template-columns:repeat(4,1fr);
  }
  ```

  

- **flex布局和grid布局不是互相替代的关系，而是互相合作的关系**，在一个复杂的页面中，**通常用grid做全局化粗粒度的布局，然后再用flex布局对每个网格进行细粒度的布局**。